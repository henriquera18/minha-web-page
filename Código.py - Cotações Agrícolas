# ======= IMPORTA√á√ïES =======
import requests
from bs4 import BeautifulSoup
from datetime import datetime
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, ContextTypes, filters
import matplotlib.pyplot as plt
import os
import csv

# ======= CONFIGURA√á√ïES =======
TOKEN = '8025778957:AAERWvcrdy09Dxow-dHuSA2P0IzzGPxLyMQ'
URL = 'https://www.noticiasagricolas.com.br/cotacoes/'
ARQUIVO_CSV = 'cotacoes.csv'

# ======= COMANDO /start =======
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    dados = atualizar()
    context.user_data['dados'] = dados
    mensagem = (
        "üë©‚Äçüåæ Ol√°, seja bem-vindo ao Bot de Cota√ß√µes Agr√≠colas!\n\n"
        "üìä Aqui voc√™ pode consultar os pre√ßos atualizados de produtos do agroneg√≥cio.\n"
        "üëâ Escolha um produto abaixo para ver as cota√ß√µes e gr√°ficos.\n"
    )
    await exibir_menu(update, context, mensagem)

# ======= EXIBE MENU DE PRODUTOS =======
async def exibir_menu(update: Update, context: ContextTypes.DEFAULT_TYPE, texto='üëã Escolha o produto:'):
    dados = context.user_data.get('dados', [])
    produtos = sorted(set(d[0] for d in dados if d[2]))
    if not produtos:
        texto = "‚ö†Ô∏è Nenhuma cota√ß√£o dispon√≠vel no momento. Tente novamente mais tarde."
    botoes = [[InlineKeyboardButton(f'üåΩ {p}', callback_data=p)] for p in produtos]
    markup = InlineKeyboardMarkup(botoes)
    if update.message:
        await update.message.reply_text(texto, reply_markup=markup)
    else:
        await update.callback_query.message.reply_text(texto, reply_markup=markup)

# ======= RESPOSTAS A BOT√ïES =======
async def responder_botao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    produto = query.data

    if produto == 'voltar_menu':
        await start(update, context)
        return

    dados = context.user_data.get('dados', [])
    filtrados = [d for d in dados if d[0] == produto and d[2]]
    if not filtrados:
        await query.message.reply_text('‚ö†Ô∏è Nenhuma cota√ß√£o dispon√≠vel.',
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton('üîô Voltar ao Menu', callback_data='voltar_menu')]]))
        return

    msg = f"<b>{produto.upper()}</b> - {datetime.now():%d/%m/%Y}\n"
    cidades = []
    precos = []
    for _, local, preco in filtrados:
        msg += f"üìç <b>{local}</b>\nüí∞ R$ {float(preco):.2f}\n‚îÄ‚îÄ‚îÄ‚îÄ\n"
        cidades.append(local)
        precos.append(float(preco))

    caminho = f"grafico_{produto}.png"
    plt.figure(figsize=(9, 5))
    plt.bar(cidades, precos, color='green')
    plt.xticks(rotation=45, ha='right')
    plt.ylabel('Pre√ßo (R$)')
    plt.title(f'Comparativo de Pre√ßos - {produto}')
    plt.tight_layout()
    plt.savefig(caminho)
    plt.close()

    await query.message.reply_photo(
        photo=open(caminho, 'rb'),
        caption=msg,
        parse_mode='HTML',
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton('üîô Voltar ao Menu', callback_data='voltar_menu')]])
    )

# ======= MENSAGEM PADR√ÉO CASO N√ÉO COMANDO =======
async def fallback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('‚ÑπÔ∏è Use /start para come√ßar.')

# ======= ATUALIZA√á√ÉO VIA WEBSCRAPING =======
def atualizar():
    dados = extrair()
    salvar_csv(dados)
    return dados

# ======= WEBSCRAPING DO SITE =======
def extrair():
    r = requests.get(URL)
    s = BeautifulSoup(r.text, 'html.parser')
    resultados = []
    produto = ''
    for el in s.find_all(['h2', 'table']):
        if el.name == 'h2':
            produto = el.text.strip()
        elif el.name == 'table':
            for linha in el.select('tr')[1:]:
                cols = linha.select('td')
                if len(cols) >= 2:
                    local = cols[0].get_text(strip=True)
                    preco = cols[1].get_text(strip=True).replace('R$', '').replace(',', '.').strip()
                    try:
                        preco_float = float(preco)
                        resultados.append([produto, local, preco_float])
                    except:
                        continue
    return resultados

# ======= SALVA CSV (OPCIONAL) =======
def salvar_csv(dados):
    with open(ARQUIVO_CSV, 'w', newline='', encoding='utf-8') as f:
        csv.writer(f).writerows([['Produto', 'Local', 'Preco']] + dados)

# ======= INICIALIZA√á√ÉO DO BOT =======
if __name__ == '__main__':
    app = ApplicationBuilder().token(TOKEN).build()
    app.add_handler(CommandHandler('start', start))
    app.add_handler(CallbackQueryHandler(responder_botao))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, fallback))
    print("ü§ñ Bot rodando...")
    app.run_polling()
